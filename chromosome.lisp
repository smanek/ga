(in-package :ga)

(defclass chromosome ()
  ;;a simple chromosome class, to represent an individual.
  ;;I keep the image/score around because they are very expensive to compute
  ;;and I want to avoid redoing work I've already done
  ((polygons :accessor get-polygons 
	     :initarg :polygons)
   (image    :accessor get-image
	     :initarg :image)
   (score    :accessor get-score
	     :initarg :score)
   (width    :initarg :width
	     :accessor get-width)
   (height   :initarg :height
	     :accessor get-height)
   (source   :reader get-source  ;;source is useful for debugging. It tells me if a chromosome is a child, mutation, etc.
	     :initarg :source
	     :initform 'default)
   (age      :accessor get-age ;;if all the chromosomes in my population are old, I've probably hit a local max
	     :initform 0)
   (uid      :initarg :uid ;;also useful for debugging. I can see the total number of chromosomes generated
	     :initform 0
	     :reader uid)))

(defmethod print-object ((c chromosome) stream)
  (print-unreadable-object (c stream :type t)
    (with-slots (score source polygons age uid) c
      (format stream "~A: Score = ~A, Source = ~A, polygons = ~A, age = ~A" uid score source (length polygons) age))))

(defmethod make-image ((c chromosome))
  ;;compute the image for chromosome, by drawing its polygons on its bitmap
  (let ((image (make-bitmap (get-width c) (get-height c))))
    (loop for polygon in (get-polygons c)
       do (draw-filled-polygon image polygon)
       finally (return image))))


(let ((uid 0))
  (defun make-chromosome (polygons goal-bmp source)
    "I want to create an image and compute a score anytime I create a chromosome. This constructor fn seemed cleaner than :after methods."
    (destructuring-bind (x y) (array-dimensions goal-bmp)
      (let ((res (make-instance 'chromosome 
				:polygons polygons
				:width x
				:height y
				:source source
				:uid (incf uid))))     
	(setf (get-image res) (make-image res))
					;      (setf (get-image res) (make-bitmap x y))
	(setf (get-score res) (difference-bmps (get-image res) goal-bmp x y))
	(debug-print 9 "Creating a chromosome (~A, ~A) with:~%~{~T~T~A~%~}~%" source (get-score res) polygons)
	res))))

(defun make-random-chromosome (goal-bmp)
  "Make a random chromsome of the same size as goal-bmp (and whose score is computed as its distance from the goal)"
  (destructuring-bind (x y) (array-dimensions goal-bmp)
    (make-chromosome (make-random-polygons *min-initial-polygons* *max-initial-polygons* 
					   x y
					   *max-polygon-vertices*)
		     goal-bmp
		     'random)))

(defun make-random-chromosomes (goal-bmp count)
  "Make count random chromosomes"
  (loop for i from 1 upto count
     collecting (sb-thread:make-thread (lambda () (make-random-chromosome goal-bmp)))
     into random-threads
     finally (return (mapcar #'sb-thread:join-thread random-threads))))

(defmethod offspring ((a chromosome) (b chromosome) goal)
  "Create the offspring of two chromsomes. I found I got better results if I didn't mutate here, 
and instead seperately mutated members of my population."
  (let ((res (make-chromosome (loop for polygon in (get-polygons a) 
				 with other-index = 0
				 with other-len = (length (get-polygons b))
				 with other-p = (shuffle (get-polygons b))
				 collecting (if (and (> (random 1.0) *crossover-rate*)
						     (> other-len other-index))
						(prog1 
						    (elt other-p other-index)
						  (incf other-index))
						polygon))
			      goal
			      'breeding)))
    (debug-print 7 "Creating child chromosome ~A from ~A and ~A." res a b)
    res))

(defmethod mutate-chromosome ((a chromosome) goal)
  "Mutate a chromosome in accordance to the probabilities in global.lisp."
  (let ((res (make-chromosome (mutate-polygons (get-polygons a) (get-width a) (get-height a)) 
			      goal 'mutation)))
    (debug-print 7 "Mutating chromosome ~A to ~A" a res)
    res))

(defun mutate (wpop count goal)
  "Mutate count individuals from a weighted list of a population"
  (loop for i from 1 upto count
     ;;Break off the actual computations into seperate threads to take advantage of multiple cores
     collecting (sb-thread:make-thread (lambda () (mutate-chromosome (car (choose-from-weighted-lst wpop 1)) goal)))
     into threads
     ;;combine the results generated by the threads
     finally (return (mapcar #'sb-thread:join-thread threads))))

(defmethod write-chromosome ((a chromosome) generation number)
  (write-bmp-file (get-image a)  
		  (format nil "~A~A-~A~A" *output-directory* generation number *output-type*)))

(defun breed (wpop children goal)
  "Create children from a weighted list of a population"
  (loop for i from 1 upto children
     ;;break off the CPU intense computations into threads
     collecting (sb-thread:make-thread (lambda () (apply #'offspring
							 (append (choose-from-weighted-lst wpop 2)
								 (list goal)))))
     into threads
     ;;combine the results from the threads
     finally (return (mapcar #'sb-thread:join-thread threads))))